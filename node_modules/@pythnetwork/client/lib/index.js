"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parsePriceData = exports.parseProductData = exports.parseMappingData = exports.DeriveType = exports.PriceType = exports.CorpAction = exports.PriceStatus = exports.Version = exports.Version2 = exports.Magic = void 0;
var web3_js_1 = require("@solana/web3.js");
var buffer_1 = require("buffer");
var readBig_1 = require("./readBig");
exports.Magic = 0xa1b2c3d4;
exports.Version2 = 2;
exports.Version = exports.Version2;
exports.PriceStatus = ['Unknown', 'Trading', 'Halted', 'Auction'];
exports.CorpAction = ['NoCorpAct'];
exports.PriceType = ['Unknown', 'Price'];
exports.DeriveType = ['Unknown', 'TWAP', 'Volatility'];
var empty32Buffer = buffer_1.Buffer.alloc(32);
var PKorNull = function (data) { return (data.equals(empty32Buffer) ? null : new web3_js_1.PublicKey(data)); };
var parseMappingData = function (data) {
    // pyth magic number
    var magic = data.readUInt32LE(0);
    // program version
    var version = data.readUInt32LE(4);
    // account type
    var type = data.readUInt32LE(8);
    // account used size
    var size = data.readUInt32LE(12);
    // number of product accounts
    var numProducts = data.readUInt32LE(16);
    // unused
    // const unused = accountInfo.data.readUInt32LE(20)
    // next mapping account (if any)
    var nextMappingAccount = PKorNull(data.slice(24, 56));
    // read each symbol account
    var offset = 56;
    var productAccountKeys = [];
    for (var i = 0; i < numProducts; i++) {
        var productAccountBytes = data.slice(offset, offset + 32);
        var productAccountKey = new web3_js_1.PublicKey(productAccountBytes);
        offset += 32;
        productAccountKeys.push(productAccountKey);
    }
    return {
        magic: magic,
        version: version,
        type: type,
        size: size,
        nextMappingAccount: nextMappingAccount,
        productAccountKeys: productAccountKeys,
    };
};
exports.parseMappingData = parseMappingData;
var parseProductData = function (data) {
    // pyth magic number
    var magic = data.readUInt32LE(0);
    // program version
    var version = data.readUInt32LE(4);
    // account type
    var type = data.readUInt32LE(8);
    // price account size
    var size = data.readUInt32LE(12);
    // first price account in list
    var priceAccountBytes = data.slice(16, 48);
    var priceAccountKey = new web3_js_1.PublicKey(priceAccountBytes);
    var product = {};
    var idx = 48;
    while (idx < size) {
        var keyLength = data[idx];
        idx++;
        if (keyLength) {
            var key = data.slice(idx, idx + keyLength).toString();
            idx += keyLength;
            var valueLength = data[idx];
            idx++;
            var value = data.slice(idx, idx + valueLength).toString();
            idx += valueLength;
            product[key] = value;
        }
    }
    return { magic: magic, version: version, type: type, size: size, priceAccountKey: priceAccountKey, product: product };
};
exports.parseProductData = parseProductData;
var parseEma = function (data, exponent) {
    // current value of ema
    var valueComponent = readBig_1.readBigInt64LE(data, 0);
    var value = Number(valueComponent) * Math.pow(10, exponent);
    // numerator state for next update
    var numerator = readBig_1.readBigInt64LE(data, 8);
    // denominator state for next update
    var denominator = readBig_1.readBigInt64LE(data, 16);
    return { valueComponent: valueComponent, value: value, numerator: numerator, denominator: denominator };
};
var parsePriceInfo = function (data, exponent) {
    // aggregate price
    var priceComponent = readBig_1.readBigInt64LE(data, 0);
    var price = Number(priceComponent) * Math.pow(10, exponent);
    // aggregate confidence
    var confidenceComponent = readBig_1.readBigUInt64LE(data, 8);
    var confidence = Number(confidenceComponent) * Math.pow(10, exponent);
    // aggregate status
    var status = data.readUInt32LE(16);
    // aggregate corporate action
    var corporateAction = data.readUInt32LE(20);
    // aggregate publish slot
    var publishSlot = readBig_1.readBigUInt64LE(data, 24);
    return {
        priceComponent: priceComponent,
        price: price,
        confidenceComponent: confidenceComponent,
        confidence: confidence,
        status: status,
        corporateAction: corporateAction,
        publishSlot: publishSlot,
    };
};
var parsePriceData = function (data) {
    // pyth magic number
    var magic = data.readUInt32LE(0);
    // program version
    var version = data.readUInt32LE(4);
    // account type
    var type = data.readUInt32LE(8);
    // price account size
    var size = data.readUInt32LE(12);
    // price or calculation type
    var priceType = data.readUInt32LE(16);
    // price exponent
    var exponent = data.readInt32LE(20);
    // number of component prices
    var numComponentPrices = data.readUInt32LE(24);
    // number of quoters that make up aggregate
    var numQuoters = data.readUInt32LE(28);
    // slot of last valid (not unknown) aggregate price
    var lastSlot = readBig_1.readBigUInt64LE(data, 32);
    // valid on-chain slot of aggregate price
    var validSlot = readBig_1.readBigUInt64LE(data, 40);
    // time-weighted average price
    var twap = parseEma(data.slice(48, 72), exponent);
    // time-weighted average confidence interval
    var twac = parseEma(data.slice(72, 96), exponent);
    // space for future derived values
    var drv1Component = readBig_1.readBigInt64LE(data, 96);
    var drv1 = Number(drv1Component) * Math.pow(10, exponent);
    var drv2Component = readBig_1.readBigInt64LE(data, 104);
    var drv2 = Number(drv2Component) * Math.pow(10, exponent);
    // product id / reference account
    var productAccountKey = new web3_js_1.PublicKey(data.slice(112, 144));
    // next price account in list
    var nextPriceAccountKey = PKorNull(data.slice(144, 176));
    // valid slot of previous update
    var previousSlot = readBig_1.readBigUInt64LE(data, 176);
    // aggregate price of previous update
    var previousPriceComponent = readBig_1.readBigInt64LE(data, 184);
    var previousPrice = Number(previousPriceComponent) * Math.pow(10, exponent);
    // confidence interval of previous update
    var previousConfidenceComponent = readBig_1.readBigUInt64LE(data, 192);
    var previousConfidence = Number(previousConfidenceComponent) * Math.pow(10, exponent);
    // space for future derived values
    var drv3Component = readBig_1.readBigInt64LE(data, 200);
    var drv3 = Number(drv3Component) * Math.pow(10, exponent);
    var aggregatePriceInfo = parsePriceInfo(data.slice(208, 240), exponent);
    // price components - up to 32
    var priceComponents = [];
    var offset = 240;
    var shouldContinue = true;
    while (offset < data.length && shouldContinue) {
        var publisher = PKorNull(data.slice(offset, offset + 32));
        offset += 32;
        if (publisher) {
            var aggregate = parsePriceInfo(data.slice(offset, offset + 32), exponent);
            offset += 32;
            var latest = parsePriceInfo(data.slice(offset, offset + 32), exponent);
            offset += 32;
            priceComponents.push({ publisher: publisher, aggregate: aggregate, latest: latest });
        }
        else {
            shouldContinue = false;
        }
    }
    return __assign(__assign({ magic: magic,
        version: version,
        type: type,
        size: size,
        priceType: priceType,
        exponent: exponent,
        numComponentPrices: numComponentPrices,
        numQuoters: numQuoters,
        lastSlot: lastSlot,
        validSlot: validSlot,
        twap: twap,
        twac: twac,
        drv1Component: drv1Component,
        drv1: drv1,
        drv2Component: drv2Component,
        drv2: drv2,
        productAccountKey: productAccountKey,
        nextPriceAccountKey: nextPriceAccountKey,
        previousSlot: previousSlot,
        previousPriceComponent: previousPriceComponent,
        previousPrice: previousPrice,
        previousConfidenceComponent: previousConfidenceComponent,
        previousConfidence: previousConfidence,
        drv3Component: drv3Component,
        drv3: drv3 }, aggregatePriceInfo), { priceComponents: priceComponents });
};
exports.parsePriceData = parsePriceData;
