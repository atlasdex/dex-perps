"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFundingPaymentsHistory = exports.getFundingPaymentsHistoryForUser = exports.extractTradeInfoFromTransaction = exports.getPastTrades = exports.getPastInstructions = exports.getLiquidationTransaction = exports.getMangoOraclePrice = exports.getPriceAccountKey = exports.getOraclePrice = exports.getMarketState = exports.getUserAccountsForOwner = exports.getOrders = void 0;
const client_1 = require("@pythnetwork/client");
const borsh_1 = require("borsh");
const bindings_1 = require("./bindings");
const instructions_1 = require("./instructions");
const oracle_utils_1 = require("./oracle_utils");
const state_1 = require("./state");
const utils_1 = require("./utils");
async function getOrders(connection, owner) {
    let orders = [];
    const accounts = await getUserAccounts(connection, owner);
    for (let p of accounts) {
        try {
            let parsed = state_1.UserAccount.parse(p.publicKey, p.accountInfo.data);
            let market = parsed.market;
            for (let idx = 0; idx < parsed.openPositions.length; idx++) {
                orders.push({
                    userAccount: p.publicKey,
                    position: parsed.openPositions[idx],
                    position_index: idx,
                    market,
                });
            }
        }
        catch (err) {
            console.log(`Found corrupted UserAccount at,${p.publicKey.toBase58()} - error ${err} - Skipping.`);
        }
    }
    return orders;
}
exports.getOrders = getOrders;
async function getUserAccounts(connection, owner) {
    const filters = [
        {
            memcmp: {
                offset: 2,
                bytes: owner.toBase58(),
            },
        },
    ];
    return await utils_1.getFilteredProgramAccounts(connection, bindings_1.PERPS_PROGRAM_ID, filters);
}
async function getUserAccountsForOwner(connection, owner) {
    return (await getUserAccounts(connection, owner)).map((p) => {
        console.log(p.publicKey.toBase58());
        try {
            return state_1.UserAccount.parse(p.publicKey, p.accountInfo.data);
        }
        catch {
            console.log("Found corrupted UserAccount at ", p.publicKey.toBase58(), ". Skipping.");
        }
    });
}
exports.getUserAccountsForOwner = getUserAccountsForOwner;
async function getMarketState(connection, marketAddress) {
    return await state_1.MarketState.retrieve(connection, marketAddress);
}
exports.getMarketState = getMarketState;
// This applies to the Pyth Oracle only
async function getOraclePrice(connection, oraclePriceAccountAddress) {
    var _a;
    let oracle_data = (_a = (await connection.getAccountInfo(oraclePriceAccountAddress))) === null || _a === void 0 ? void 0 : _a.data;
    if (!oracle_data) {
        throw "Unable to retrieve oracle data";
    }
    let { price, confidence } = client_1.parsePriceData(oracle_data);
    return { price, confidence };
}
exports.getOraclePrice = getOraclePrice;
// This applies to the Pyth Oracle only
async function getPriceAccountKey(connection, marketSymbol) {
    let mappingAccountInfo = await connection.getAccountInfo(bindings_1.PYTH_MAPPING_ACCOUNT);
    if (!mappingAccountInfo) {
        throw "Unable to retrieve mapping oracle data";
    }
    const { productAccountKeys } = client_1.parseMappingData(mappingAccountInfo.data);
    for (let k of productAccountKeys) {
        let productAccountInfo = await connection.getAccountInfo(k);
        if (!productAccountInfo) {
            throw "Unable to retrieve product oracle data";
        }
        const { product, priceAccountKey } = client_1.parseProductData(productAccountInfo.data);
        if (product["symbol"] == marketSymbol) {
            return priceAccountKey;
        }
    }
    throw "Could not find the requested symbol.";
}
exports.getPriceAccountKey = getPriceAccountKey;
async function getMangoOraclePrice(connection, oracleAddress) {
    var _a;
    let oracle_data = (_a = (await connection.getAccountInfo(oracleAddress))) === null || _a === void 0 ? void 0 : _a.data;
    if (!oracle_data) {
        throw "Unable to retrieve oracle data";
    }
    let oracle = borsh_1.deserialize(oracle_utils_1.MangoOracle.schema, oracle_utils_1.MangoOracle, oracle_data);
    return oracle.answer_median / 10 ** oracle.decimals;
}
exports.getMangoOraclePrice = getMangoOraclePrice;
async function getLiquidationTransaction(connection, closeSignature, marketAddress, side) {
    var _a;
    let re = /Program log: Order not found, it was liquidated at index: (?<liquidationIndex>.*), with collateral (?<collateral>.*), with parent node slot (?<parentNodeSlot>.*)/;
    let tx = await connection.getParsedConfirmedTransaction(closeSignature, "confirmed");
    let logMessages = (_a = tx === null || tx === void 0 ? void 0 : tx.meta) === null || _a === void 0 ? void 0 : _a.logMessages;
    if (!logMessages) {
        throw "Failed to parse transaction";
    }
    let liquidationIndex = 0;
    for (let l of logMessages) {
        let m = l.match(re);
        if (!!m) {
            liquidationIndex = parseInt(m.groups["liquidationIndex"]);
        }
    }
    let side_sign = side * 2 - 1;
    let re2 = /Program log: Liquidation index: (?<liquidationIndex>.*)/;
    let lastSignature = closeSignature;
    while (true) {
        let txs = await getPastInstructions(connection, instructions_1.LIQUIDATION_LABEL, marketAddress, {
            before: lastSignature,
        });
        lastSignature = txs[txs.length - 1].signature;
        for (let t of txs) {
            let logMessages = t.log;
            for (let l of logMessages) {
                let m = l.match(re2);
                if (!!m) {
                    let actualLiquidationIndex = parseInt(m.groups["liquidationIndex"]);
                    if ((liquidationIndex - actualLiquidationIndex) * side_sign >= 0) {
                        // Found a liquidation transaction which proves that the position has been liquidated.
                        return t.signature;
                    }
                }
            }
        }
    }
}
exports.getLiquidationTransaction = getLiquidationTransaction;
async function getPastInstructions(connection, lookupAddress, marketAddress, options) {
    let sigs = await connection.getConfirmedSignaturesForAddress2(lookupAddress, options, "confirmed");
    console.log("Retrieved signatures: ", sigs.length);
    let pastInstructions = (await getPastInstructionsRaw(connection, lookupAddress, marketAddress, options)).map(parseRawInstruction);
    return pastInstructions;
}
exports.getPastInstructions = getPastInstructions;
const getFees = (logs) => {
    if (!logs)
        return;
    const regex = /Fees : Fees { total: (?<total>.*), refundable: (?<refundable>.*), fixed: (?<fixed>.*) }/;
    for (let log of logs) {
        let result = log.match(regex);
        if (!!(result === null || result === void 0 ? void 0 : result.groups)) {
            let fees;
            fees = {
                total: parseInt(result.groups.total),
                refundable: parseInt(result.groups.refundable),
                fixed: parseInt(result.groups.fixed),
            };
            return fees;
        }
    }
};
async function getPastInstructionsRaw(connection, lookupAddress, marketAddress, options) {
    var _a;
    let sigs = await connection.getConfirmedSignaturesForAddress2(lookupAddress, options, "confirmed");
    console.log("Retrieved signatures: ", sigs.length);
    let pastInstructions = [];
    let i = 0;
    for (let s of sigs) {
        console.log("Retrieving ", i, " with sig ", s.signature);
        i++;
        let tx_null = await connection.getConfirmedTransaction(s.signature, "confirmed");
        if (!tx_null || !!((_a = tx_null === null || tx_null === void 0 ? void 0 : tx_null.meta) === null || _a === void 0 ? void 0 : _a.err)) {
            continue;
        }
        let tx = tx_null;
        let tradeIndex = 0;
        tx.transaction.instructions.forEach((i) => {
            var _a;
            if (i.programId.toBase58() !== bindings_1.PERPS_PROGRAM_ID.toBase58()) {
                console.log("skipped with programId: ", i.programId.toBase58());
                return;
            }
            if (!i.keys.find((k) => {
                return k.pubkey.toBase58() === marketAddress.toBase58();
            })) {
                console.log("Skipped irrelevant instruction");
                // This instruction is irrelevant to the current market
                return;
            }
            let log = (_a = tx.meta) === null || _a === void 0 ? void 0 : _a.logMessages;
            pastInstructions.push({
                signature: s.signature,
                instruction: i,
                time: tx.blockTime,
                slot: tx.slot,
                log,
                feePayer: tx.transaction.feePayer,
                tradeIndex,
            });
            if (i.data[0] in [2, 5, 6]) {
                tradeIndex++;
            }
        });
    }
    console.log("Retrieved raw past instructions");
    return pastInstructions;
}
async function getPastTrades(connection, marketAddress, options) {
    let pastInstructions = await getPastInstructionsRaw(connection, instructions_1.TRADE_LABEL, marketAddress, options);
    console.log("Unfiltered length: ", pastInstructions.length);
    let filtered = pastInstructions.filter((i) => {
        return ([3, 6, 7].includes(i.instruction.data[0]) &&
            i.instruction.programId.toBase58() === bindings_1.PERPS_PROGRAM_ID.toBase58());
    });
    console.log("Filtered length: ", filtered.length);
    let parsed = filtered
        .map(parseRawInstruction)
        .map(extractTradeInfo)
        .map((t) => {
        t.marketAddress = marketAddress;
        return t;
    });
    return parsed;
}
exports.getPastTrades = getPastTrades;
function parseRawInstruction(i) {
    return {
        instruction: instructions_1.parseInstructionData(i.instruction.data),
        slot: i.slot,
        time: i.time,
        log: i.log,
        feePayer: i.feePayer,
        tradeIndex: i.tradeIndex,
        signature: i.signature,
        fees: getFees(i.log),
    };
}
async function extractTradeInfoFromTransaction(connection, txSig) {
    let tx_null = await connection.getConfirmedTransaction(txSig, "confirmed");
    if (!tx_null) {
        throw "Could not retrieve transaction";
    }
    let tx = tx_null;
    let instructions = tx_null.transaction.instructions.filter((i) => i.programId.toBase58() === bindings_1.PERPS_PROGRAM_ID.toBase58());
    instructions = instructions.filter((v) => [3, 6, 7].includes(v.data[0]));
    let parsedInstructions = instructions.map((v, idx) => {
        var _a;
        return {
            signature: txSig,
            instruction: v,
            time: tx.blockTime,
            slot: tx.slot,
            log: (_a = tx.meta) === null || _a === void 0 ? void 0 : _a.logMessages,
            feePayer: tx.transaction.feePayer,
            tradeIndex: idx,
        };
    });
    return parsedInstructions.map(parseRawInstruction).map(extractTradeInfo);
}
exports.extractTradeInfoFromTransaction = extractTradeInfoFromTransaction;
const markPriceExtractionRe = /Program log: Mark price for this transaction \(FP32\): (?<markPrice>.*), with size: (?<orderSize>.*) and side (?<side>.*)/;
function extractTradeInfo(i) {
    var _a, _b, _c;
    if (!i.log) {
        throw "Unable to parse mark price due to empty log";
    }
    let currentTradeIndex = 0;
    let markPrice;
    let orderSize;
    let side;
    for (let l of i.log) {
        let results = l.match(markPriceExtractionRe);
        if (!results) {
            continue;
        }
        if (currentTradeIndex === i.tradeIndex) {
            let markPriceStr = (_a = results.groups) === null || _a === void 0 ? void 0 : _a.markPrice;
            let orderSizeStr = (_b = results.groups) === null || _b === void 0 ? void 0 : _b.orderSize;
            let sideStr = (_c = results.groups) === null || _c === void 0 ? void 0 : _c.side;
            markPrice = parseInt(markPriceStr) / 2 ** 32;
            orderSize = parseInt(orderSizeStr) / Math.pow(10, 6);
            if (sideStr === "Long") {
                side = instructions_1.PositionType.Long;
            }
            else {
                side = instructions_1.PositionType.Short;
            }
        }
        currentTradeIndex++;
    }
    return {
        instruction: i,
        marketAddress: undefined,
        markPrice,
        orderSize,
        side,
    };
}
const fundingRegex = /Program log: Extracting (?<funding>.*) from user account for funding/;
async function getFundingPaymentsHistoryForUser(connection, userAccount, marketAddress, options) {
    var _a, _b, _c, _d;
    let txs = await connection.getConfirmedSignaturesForAddress2(userAccount, options, "confirmed");
    let fundingSignatures = [];
    for (let t of txs) {
        let details = await connection.getConfirmedTransaction(t.signature, "confirmed");
        let instructions = details === null || details === void 0 ? void 0 : details.transaction.instructions;
        if (!instructions) {
            continue;
        }
        let fundingPayer = "";
        let containsFunding = false;
        for (let i of instructions) {
            if (i.programId.toBase58() !== bindings_1.PERPS_PROGRAM_ID.toBase58() ||
                i.data[0] != 11 ||
                i.keys[0].pubkey.toBase58() !== marketAddress.toBase58()) {
                continue;
            }
            fundingPayer = i.keys[2].pubkey.toBase58(); // User account paying the funding
            containsFunding = true;
            break;
        }
        let fundingExtracted = undefined;
        if (!((_a = details === null || details === void 0 ? void 0 : details.meta) === null || _a === void 0 ? void 0 : _a.logMessages)) {
            continue;
        }
        for (let log of (_b = details === null || details === void 0 ? void 0 : details.meta) === null || _b === void 0 ? void 0 : _b.logMessages) {
            const results = log === null || log === void 0 ? void 0 : log.match(fundingRegex);
            if (!results || !((_c = results === null || results === void 0 ? void 0 : results.groups) === null || _c === void 0 ? void 0 : _c.funding)) {
                continue;
            }
            fundingExtracted = parseFloat((_d = results === null || results === void 0 ? void 0 : results.groups) === null || _d === void 0 ? void 0 : _d.funding);
        }
        if (containsFunding && !!fundingExtracted) {
            fundingSignatures.push({
                funding: fundingExtracted,
                signature: t.signature,
                fundingPayer: fundingPayer,
            });
        }
    }
    return fundingSignatures;
}
exports.getFundingPaymentsHistoryForUser = getFundingPaymentsHistoryForUser;
async function getFundingPaymentsHistory(connection, marketAddress, options) {
    var _a, _b, _c, _d;
    let txs = await connection.getConfirmedSignaturesForAddress2(instructions_1.FUNDING_EXTRACTION_LABEL, options, "confirmed");
    let crankedFundingSignatures = [];
    for (let t of txs) {
        let details = await connection.getConfirmedTransaction(t.signature, "confirmed");
        let instructions = details === null || details === void 0 ? void 0 : details.transaction.instructions;
        if (!instructions) {
            console.log("Empty instructions");
            continue;
        }
        let fundingPayer = "";
        let containsCrankFunding = false;
        for (let i of instructions) {
            if (i.programId.toBase58() !== bindings_1.PERPS_PROGRAM_ID.toBase58() ||
                i.data[0] != 11 ||
                i.keys[0].pubkey.toBase58() !== marketAddress.toBase58()) {
                console.log("Skpping instruction");
                continue;
            }
            containsCrankFunding = true;
            fundingPayer = i.keys[2].pubkey.toBase58(); // User account paying the funding
            break;
        }
        let fundingExtracted = undefined;
        if (!((_a = details === null || details === void 0 ? void 0 : details.meta) === null || _a === void 0 ? void 0 : _a.logMessages)) {
            continue;
        }
        for (let log of (_b = details === null || details === void 0 ? void 0 : details.meta) === null || _b === void 0 ? void 0 : _b.logMessages) {
            const results = log === null || log === void 0 ? void 0 : log.match(fundingRegex);
            if (!results || !((_c = results === null || results === void 0 ? void 0 : results.groups) === null || _c === void 0 ? void 0 : _c.funding)) {
                continue;
            }
            fundingExtracted = parseFloat((_d = results === null || results === void 0 ? void 0 : results.groups) === null || _d === void 0 ? void 0 : _d.funding);
        }
        if (containsCrankFunding && !!fundingExtracted) {
            crankedFundingSignatures.push({
                funding: fundingExtracted,
                signature: t.signature,
                fundingPayer: fundingPayer,
            });
        }
    }
    return crankedFundingSignatures;
}
exports.getFundingPaymentsHistory = getFundingPaymentsHistory;
//# sourceMappingURL=secondary_bindings.js.map