"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getMarkPrice = exports.getMarketTrades = exports.getTradeInfoFromTx = exports.getOpenPositions = exports.reducePositionCollateral = exports.completeClosePosition = exports.reducePositionBaseSize = exports.increasePositionCollateral = exports.increasePositionBaseSize = exports.createPosition = exports.withdrawCollateral = exports.depositCollateral = exports.createUserAccount = exports.getDiscountAccount = exports.getQuoteAccount = exports.initWallet = exports.BNB_ADDRESS = void 0;
// More user friendly than the ones in bindings.ts and secondary_bindings.ts
const web3_js_1 = require("@solana/web3.js");
const bindings_1 = require("./bindings");
const utils_1 = require("./utils");
const secondary_bindings_1 = require("./secondary_bindings");
const Cache = new Map();
var Env;
(function (Env) {
    Env["dev"] = "dev";
    Env["prod"] = "prod";
})(Env || (Env = {}));
exports.BNB_ADDRESS = new web3_js_1.PublicKey("4qZA7RixzEgQ53cc6ittMeUtkaXgCnjZYkP8L1nxFD25");
// Assumes the wallet used for trading has an associated token account for USDC
// If it's not the case run the following initWallet function
const USDC_MINT = new web3_js_1.PublicKey("EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v");
// FIDA token mint
const FIDA_MINT = new web3_js_1.PublicKey("EchesyfXePKdLtoiZSL8pBe8Myagyy8ZRqsACNCFGnvp");
/**
 * Creates an associated USDC account for a wallet.
 *
 * @param connection The solana connection object to the RPC node.
 * @param wallet The wallet that does not have an associated USDC account. Needs to sign.
 * @returns The signature of the transaction.
 */
const initWallet = async (connection, wallet) => {
    const instruction = await utils_1.createAssociatedTokenAccount(wallet.publicKey, wallet.publicKey, USDC_MINT);
    const tx = await utils_1.signAndSendTransactionInstructions(connection, [], wallet, [
        instruction,
    ]);
    return tx;
};
exports.initWallet = initWallet;
/**
 * Returns the USDC associated token account of a wallet.
 *
 * @param connection The solana connection object to the RPC node.
 * @param wallet The wallet owning the associated USDC account.
 * @returns The public key of the USDC associated token account of the wallet.
 */
const getQuoteAccount = async (wallet) => {
    if (!Cache.get("quoteAccount")) {
        const associatedUSDCAccount = await utils_1.findAssociatedTokenAddress(wallet, USDC_MINT);
        Cache.set("quoteAccount", associatedUSDCAccount);
    }
    // @ts-ignore
    return Cache.get("quoteAccount");
};
exports.getQuoteAccount = getQuoteAccount;
/**
 * Returns the FIDA associated token account of a wallet.
 *
 * @param connection The solana connection object to the RPC node.
 * @param wallet The wallet owning the associated USDC account.
 * @returns The public key of the USDC associated token account of the wallet.
 */
const getDiscountAccount = async (connection, wallet, env = Env.prod) => {
    if (env === Env.dev) {
        return undefined;
    }
    if (!Cache.has("discountAccount")) {
        const associatedFidaAccount = await utils_1.findAssociatedTokenAddress(wallet, FIDA_MINT);
        const accountInfo = await connection.getAccountInfo(associatedFidaAccount);
        if (!(accountInfo === null || accountInfo === void 0 ? void 0 : accountInfo.data))
            return undefined;
        Cache.set("discountAccount", associatedFidaAccount);
    }
    return Cache.get("discountAccount");
};
exports.getDiscountAccount = getDiscountAccount;
/**
 * Creates the user account i.e the intermediary account that will hold the collateral.
 *
 * @param connection The solana connection object to the RPC node.
 * @param marketAddress The address of the market, user accounts are market specific.
 * @param wallet The wallet associated to this user account.
 * @returns The primed transaction that will create the user account.
 */
const createUserAccount = async (connection, marketAddress, wallet) => {
    const quoteAccount = await exports.getQuoteAccount(wallet);
    const primedTx = await bindings_1.addBudget(connection, marketAddress, 0, wallet, quoteAccount, wallet);
    return primedTx;
};
exports.createUserAccount = createUserAccount;
/**
 * Deposit collateral (USDC) from a wallet into a user account. This does not affect directly the collateral of your positions.
 *
 * @param connection The solana connection object to the RPC node.
 * @param marketAddress The address of the market, user accounts are market specific.
 * @param amount The USDC amount to deposit from the wallet into the user account. Need to take into account the decimals i.e 1 USDC = 1 * USDC_DECIMALS = 1_000_000
 * @param wallet The wallet to debit the USDC from.
 * @param userAccount The user account to credit the USDC to.
 * @returns The primed transaction that will deposit collateral into the user account.
 */
const depositCollateral = async (connection, marketAddress, amount, wallet, userAccount) => {
    // Safety checks
    if (amount <= 0) {
        throw new Error("Invalid amount to withdraw, needs to be > 0");
    }
    const allUserAccounts = await secondary_bindings_1.getUserAccountsForOwner(connection, wallet);
    if (!allUserAccounts) {
        throw new Error("No user account found for owner");
    }
    const userAccountExists = allUserAccounts.find((acc) => acc === null || acc === void 0 ? void 0 : acc.market.equals(marketAddress));
    if (!userAccountExists) {
        throw new Error(`User account ${userAccount.toBase58()} market is not ${marketAddress.toBase58()}`);
    }
    const quoteAccount = await exports.getQuoteAccount(wallet);
    const primedTx = await bindings_1.addBudget(connection, marketAddress, amount, wallet, quoteAccount, wallet, userAccount);
    return primedTx;
};
exports.depositCollateral = depositCollateral;
/**
 * Withdraw collateral (USDC) from a user account and deposit it into a wallet. This does not affect directly the collateral of your positions.
 *
 * @param connection The solana connection object to the RPC node.
 * @param marketAddress The address of the market, user accounts are market specific.
 * @param amount The USDC amount to deposit from the user account into the wallet. Need to take into account the decimals i.e 1 USDC = 1 * USDC_DECIMALS = 1_000_000
 * @param wallet The wallet to credit the USDC to.
 * @param userAccount The user account to debit the USDC from.
 * @returns The primed transaction that will deposit collateral into the wallet.
 */
const withdrawCollateral = async (connection, marketAddress, amount, wallet, userAccount) => {
    // Safety checks
    if (amount <= 0) {
        throw new Error("Invalid amount to withdraw, needs to be > 0");
    }
    const allUserAccounts = await secondary_bindings_1.getUserAccountsForOwner(connection, wallet);
    if (!allUserAccounts) {
        throw new Error("No user account found for owner");
    }
    const userAccountExists = allUserAccounts.find((acc) => acc === null || acc === void 0 ? void 0 : acc.market.equals(marketAddress));
    if (!userAccountExists) {
        throw new Error(`User account ${userAccount.toBase58()} market is not ${marketAddress.toBase58()}`);
    }
    const quoteAccount = await exports.getQuoteAccount(wallet);
    const primedTx = await bindings_1.withdrawBudget(connection, marketAddress, amount, quoteAccount, wallet, userAccount);
    return primedTx;
};
exports.withdrawCollateral = withdrawCollateral;
/**
 * Opens a position for a user account.
 *
 * @param connection The solana connection object to the RPC node.
 * @param side The side of the position you want to open.
 * @param quoteSize The quote size i.e notional of the position you want to open.
 * @param leverage The leverage of the position you want to open.
 * @param userAccount The user account with which you want to open the position.
 * @param referrerAccount The referrer USDC account of the account (optionnal)
 * @returns The primed transaction that will increase the base size of the position.
 */
const createPosition = async (connection, side, quoteSize, leverage, userAccount, referrerAccount = undefined) => {
    const collateral = quoteSize / leverage;
    const discountAccount = await exports.getDiscountAccount(connection, userAccount.owner);
    const primedTx = await bindings_1.openPosition(connection, side, new utils_1.Numberu64(collateral), userAccount.market, userAccount.owner, leverage, userAccount.address, discountAccount, userAccount.owner, referrerAccount, exports.BNB_ADDRESS);
    return primedTx;
};
exports.createPosition = createPosition;
/**
 * Increases the base size of a position. This will increase the leverage of your position.
 *
 * @param connection The solana connection object to the RPC node.
 * @param position The position you want to increase the size.
 * @param size The size you want to add to your current position. Need to take into account the decimals.
 * @param wallet The wallet used to trade.
 * @param referrerAccount The referrer USDC account of the account (optionnal)
 * @returns The primed transaction that will increase the base size of the position.
 */
const increasePositionBaseSize = async (connection, position, size, wallet, referrerAccount = undefined, predictedEntryPrice = undefined, maximumSlippageMargin = undefined) => {
    const marketState = await secondary_bindings_1.getMarketState(connection, position.marketAddress);
    let sideSign = position.side === "long" ? 1 : -1;
    let targetSize = size + position.vCoinAmount;
    const currentQuoteSize = (position.vCoinAmount * marketState.vQuoteAmount) /
        (marketState.vCoinAmount + sideSign * position.vCoinAmount);
    const targetPositionQuoteSize = (targetSize * (marketState.vQuoteAmount - sideSign * currentQuoteSize)) /
        (marketState.vCoinAmount - sideSign * (targetSize - position.vCoinAmount));
    const targetLeverage = targetPositionQuoteSize / position.collateral;
    const amountToWithdraw = position.collateral - currentQuoteSize / targetLeverage;
    const discountAccount = await exports.getDiscountAccount(connection, wallet);
    const [signersClose, instructionsClose] = await bindings_1.closePosition(connection, new utils_1.Numberu64(amountToWithdraw), new utils_1.Numberu64(0), position.marketAddress, wallet, position.positionIndex, position.userAccount, discountAccount, wallet, referrerAccount, exports.BNB_ADDRESS, predictedEntryPrice, maximumSlippageMargin);
    const [signersIncrease, instructionIncrease] = await bindings_1.increasePosition(connection, position.marketAddress, amountToWithdraw, targetLeverage, position.positionIndex, wallet, position.userAccount, exports.BNB_ADDRESS, discountAccount, wallet, referrerAccount, predictedEntryPrice, maximumSlippageMargin);
    return [
        [...signersClose, ...signersIncrease],
        [...instructionsClose, ...instructionIncrease],
    ];
};
exports.increasePositionBaseSize = increasePositionBaseSize;
/**
 * Increases the collateral of a position. This will decrease the leverage of your position.
 *
 * @param connection The solana connection object to the RPC node.
 * @param position The position you want to increase the collateral.
 * @param wallet The wallet used to trade.
 * @param collateral The collateral to add to your current position. Need to take into account the decimals.
 * @returns The primed transaction that will increase the collateral of the position.
 */
const increasePositionCollateral = async (connection, position, wallet, collateral, referrerAccount = undefined) => {
    const discountAccount = await exports.getDiscountAccount(connection, wallet);
    const primedTx = await bindings_1.increasePosition(connection, position.marketAddress, collateral, 0, position.positionIndex, wallet, position.userAccount, exports.BNB_ADDRESS, discountAccount, wallet, referrerAccount);
    return primedTx;
};
exports.increasePositionCollateral = increasePositionCollateral;
/**
 * Reduces the base size of a position. This will decrease the leverage of your position.
 *
 * @param connection The solana connection object to the RPC node.
 * @param position The position you want to reduce the size.
 * @param wallet The wallet used to trade.
 * @param size The base size to deduce from your position. Need to take into account the decimals.
 * @param referrerAccount The referrer USDC account of the account (optionnal)
 * @returns The primed transaction that will decrease the base size of the position.
 */
const reducePositionBaseSize = async (connection, position, size, wallet, referrerAccount = undefined, predictedEntryPrice = undefined, maximumSlippageMargin = undefined) => {
    const discountAccount = await exports.getDiscountAccount(connection, wallet);
    const primedTx = await bindings_1.closePosition(connection, new utils_1.Numberu64(0), new utils_1.Numberu64(size), position.marketAddress, wallet, position.positionIndex, position.userAccount, discountAccount, wallet, referrerAccount, exports.BNB_ADDRESS, predictedEntryPrice, maximumSlippageMargin);
    return primedTx;
};
exports.reducePositionBaseSize = reducePositionBaseSize;
/**
 * Completely close a position.
 *
 * @param connection The solana connection object to the RPC node.
 * @param position The position you want to close.
 * @param wallet The wallet used to trade.
 * @param referrerAccount The referrer USDC account of the account (optionnal)
 * @returns The primed transaction that will close the position.
 */
const completeClosePosition = async (connection, position, wallet, referrerAccount = undefined) => {
    const discountAccount = await exports.getDiscountAccount(connection, wallet);
    const primedTx = await bindings_1.closePosition(connection, new utils_1.Numberu64(position.collateral), new utils_1.Numberu64(position.vCoinAmount), position.marketAddress, wallet, position.positionIndex, position.userAccount, discountAccount, wallet, referrerAccount, exports.BNB_ADDRESS);
    return primedTx;
};
exports.completeClosePosition = completeClosePosition;
/**
 * Reduces the collateral of a position.
 *
 * @param connection The solana connection object to the RPC node.
 * @param position The position you want to reduce the collateral.
 * @param wallet The wallet used to trade.
 * @param collateral The collateral to add to the position.
 * @param referrerAccount The referrer USDC account of the account (optionnal)
 * @returns The primed transaction that will reduce the collateral of the position.
 */
const reducePositionCollateral = async (connection, position, wallet, collateral, referrerAccount = undefined) => {
    const discountAccount = await exports.getDiscountAccount(connection, wallet);
    const primedTx = await bindings_1.closePosition(connection, new utils_1.Numberu64(collateral), new utils_1.Numberu64(0), position.marketAddress, wallet, position.positionIndex, position.userAccount, discountAccount, wallet, referrerAccount, exports.BNB_ADDRESS);
    return primedTx;
};
exports.reducePositionCollateral = reducePositionCollateral;
/**
 * Get all the user positions for a given market.
 *
 * @param connection The solana connection object to the RPC node.
 * @param wallet The wallet to credit the USDC to.
 * @returns An array of Position objects.
 */
const getOpenPositions = async (connection, wallet) => {
    let positions = [];
    const _positions = await secondary_bindings_1.getOrders(connection, wallet);
    for (let pos of _positions) {
        const marketState = await secondary_bindings_1.getMarketState(connection, pos.market);
        const entryPrice = pos.position.vPcAmount / pos.position.vCoinAmount;
        const leverage = pos.position.vPcAmount / pos.position.collateral;
        const pnl = pos.position.side === 1
            ? (pos.position.vCoinAmount * marketState.vQuoteAmount) /
                (marketState.vCoinAmount + pos.position.vCoinAmount) -
                pos.position.vPcAmount
            : pos.position.vPcAmount -
                (pos.position.vCoinAmount * marketState.vQuoteAmount) /
                    (marketState.vCoinAmount - pos.position.vCoinAmount);
        const size = pos.position.vCoinAmount;
        const position = {
            side: pos.position.side === 1 ? "long" : "short",
            size: size,
            pnl,
            leverage: leverage,
            liqPrice: pos.position.liquidationIndex,
            entryPrice: entryPrice,
            userAccount: pos.userAccount,
            collateral: pos.position.collateral,
            marketAddress: pos.market,
            positionIndex: pos.position_index,
            vCoinAmount: pos.position.vCoinAmount,
            instanceIndex: pos.position.instanceIndex,
        };
        positions.push(position);
    }
    return positions;
};
exports.getOpenPositions = getOpenPositions;
/**
 * Get all the information of a trade from its tx.
 *
 * @param connection The solana connection object to the RPC node.
 * @param tx The tx of the trade
 * @returns A PastTrade object.
 */
const getTradeInfoFromTx = async (connection, tx) => {
    const tradeInfo = await secondary_bindings_1.extractTradeInfoFromTransaction(connection, tx);
    return tradeInfo;
};
exports.getTradeInfoFromTx = getTradeInfoFromTx;
/**
 * Get recent market trades.
 *
 * @param connection The solana connection object to the RPC node.
 * @param marketAddress The address of the market.
 * @param limit The limit to the number of trades to return (optional)
 * @returns An array of PastTrade objects.
 */
const getMarketTrades = async (connection, marketAddress, limit = 100) => {
    const pastTrades = await secondary_bindings_1.getPastTrades(connection, marketAddress, {
        limit: limit,
    });
    return pastTrades;
};
exports.getMarketTrades = getMarketTrades;
/**
 * Get current mark price.
 *
 * @param connection The solana connection object to the RPC node.
 * @param marketAddress The address of the market.
 * @returns The current mark price of the vAMM.
 */
const getMarkPrice = async (connection, marketAddress) => {
    const markPrice = await (await secondary_bindings_1.getMarketState(connection, marketAddress)).getMarkPrice();
    return markPrice;
};
exports.getMarkPrice = getMarkPrice;
//# sourceMappingURL=high_level.js.map