import { Keypair, Connection, PublicKey, TransactionInstruction } from "@solana/web3.js";
import { Numberu64 } from "./utils";
import { PositionType } from "./instructions";
export declare const PERPS_PROGRAM_ID: PublicKey;
export declare const PYTH_MAPPING_ACCOUNT: PublicKey;
export declare const CURRENT_RECOMMENDED_INSTANCE = 0;
export declare type PrimedTransaction = [Keypair[], TransactionInstruction[]];
/**
 * Returns a signers and transaction instructions to create a new Perpetual Futures AMM. The admin account will be the
 * centralized authority capable of creating new market instances. The signers array only contains the marketAccount to be
 * created.
 *
 * @param connection The solana connection object to the RPC node
 * @param adminAccount The market's administrative authority.
 * @param feePayer The address that will pay for this operation's transaction fees.
 * @param marketSymbol The symbol of the market that is to be created, example: "BTC/USD"
 * @param quoteMint The mint address of the market's base currency token
 * @param initial_v_quote_amount The initial amount of virtual quote currency.
 * @param vCoinDecimals The number of decimals which will be used in the market's internal vCoin representation.
 * @returns An array of signer accounts and an array of instructions. The admin account will need to sign the transaction.
 */
export declare function createMarket(connection: Connection, adminAccount: PublicKey, feePayer: PublicKey, marketSymbol: string, quoteMint: PublicKey, vCoinDecimals: number, initial_v_quote_amount: Numberu64): Promise<PrimedTransaction>;
/**
 * This permissioned instruction has to be signed by the market administration key. It creates a new market instance. A particular market
 * can have multiple instances which will be cranked separately in order to allow for more scaling. Each instance has a set of memory pages
 * which adds up to its own memory
 *
 * @param connection The solana connection object to the RPC node
 * @param marketAccount The market's address.
 * @param marketAdmin The market's administrative authority.
 * @param feePayer The address that will pay for this operation's transaction fees.
 * @param numberOfPages The number of memory pages to allocate for this particular instance
 * @param pageSlots The size of the memory pages expressed in terms of memory slots (one slot = one tree node). In theory, the capacity
 * in terms of number of active positions is about half the number of slots. The limited speed of garbage collection means that it is necessary
 * to have a sufficient buffer of ready-to-use free memory at any time.
 * @returns An array of signer accounts and an array of instructions. The admin account will need to sign the transaction.
 */
export declare function addInstance(connection: Connection, marketAccount: PublicKey, marketAdmin: PublicKey, feePayer: PublicKey, numberOfPages: number, pageSlots: number): Promise<PrimedTransaction>;
/**
 * Given a UserAccount with sufficient balance, this instruction allows for the opening of long and short position at current mark price with
 * some slippage incurred by the constant product curve of the vAMM.
 *
 *
 * @param connection The solana connection object to the RPC node
 * @param side Distinguishes between longs and shorts.
 * @param collateral The amount of collateral (in base currency) to be commited to this position
 * @param marketAddress The market's address
 * @param userAccountOwner The owner of the UserAccount
 * @param leverage The positions's leverage value (can be floating point number)
 * @param userAccount The user's account which holds a certain balance of base currency as well as a collection of open positions. The user's
 * balance periodically receives or pays funding for open positions with this balance.
 * @param discountAccount (optional) A FIDA token account. Sufficient FIDA stake allows access to more efficient fee levels.
 * @param discountAccountOwner (must be specified if discountAccount is specified). The owner of the FIDA discountAccount. This account must sign
 * the eventual openPosition transaction.
 * @param referrerAccount A referrer's account which will receive a fixed portion of protocol fees.
 * @returns An array of signer accounts and an array of instructions. The userAccountOwner account will need to sign the transaction.
 */
export declare function openPosition(connection: Connection, side: PositionType, collateral: Numberu64, marketAddress: PublicKey, userAccountOwner: PublicKey, leverage: number, userAccount: PublicKey, discountAccount?: PublicKey, discountAccountOwner?: PublicKey, referrerAccount?: PublicKey, bonfida_bnb?: PublicKey, predictedEntryPrice?: number, maximumSlippageMargin?: number): Promise<PrimedTransaction>;
/**
 * Allows for the partial closing and remodeling of positions. This operation allows the user to reduce or increase the leverage of
 * their position. The resulting leverage must not exceed the constraints defined by the margin ratio. It is recommended to keep a buffer
 * between the target position's leverage and this maximum value in order to avoid immediate liquidation which can incur a loss of funds.
 *
 * @param connection The solana connection object to the RPC node.
 * @param collateral The amount of collateral to extract from the position. This can be used to increase a position's leverage.
 * @param virtualCoin The amount of virtual coin to extract from the positions. This is used to reduce the position's size. A proportional amount of
 * collateral can be extracted as well in order to avoid reducing the position's leverage.
 * @param marketAddress The market's address
 * @param userAccountOwner The owner of the UserAccount
 * @param positionIndex The target position's index in the UserAccount
 * @param userAccount The user's account which holds a certain balance of base currency as well as a collection of open positions. The user's
 * balance periodically receives or pays funding for open positions with this balance.
 * @param discountAccount (optional) A FIDA token account. Sufficient FIDA stake allows access to more efficient fee levels.
 * @param discountAccountOwner (must be specified if discountAccount is specified). The owner of the FIDA discountAccount. This account must sign
 * the eventual openPosition transaction.
 * @param referrerAccount A referrer's account which will receive a fixed portion of protocol fees.
 * @returns An array of signer accounts and an array of instructions. The userAccountOwner account will need to sign the transaction.
 */
export declare function closePosition(connection: Connection, collateral: Numberu64, virtualCoin: Numberu64, marketAddress: PublicKey, userAccountOwner: PublicKey, positionIndex: number, userAccount: PublicKey, discountAccount?: PublicKey, discountAccountOwner?: PublicKey, referrerAccount?: PublicKey, bonfida_bnb?: PublicKey, predictedEntryPrice?: number, maximumSlippageMargin?: number): Promise<PrimedTransaction>;
/**
 * A permissionless crank which is used to perform memory garbage collection maintenance operations on the market. The cranker is
 * rewarded by a flat fee per freed memory slots.
 *
 * @param connection The solana connection object to the RPC node.
 * @param maxIterations The maximum number of slots to be freed in one instruction. A value too large will exceed the Solana compute budget.
 * @param marketAddress The market's address
 * @param targetFeeAccount A base token account which will receive the cranking reward.
 * @returns An array of signer accounts and an array of instructions.
 */
export declare function collectGarbage(connection: Connection, maxIterations: number, marketAddress: PublicKey, targetFeeAccount: PublicKey): Promise<PrimedTransaction>;
/**
 * A permissionless operation which will crank liquidation operations for the market. This operation is run at high frequencies in order to
 * increase market reliability.
 *
 * @param connection The solana connection object to the RPC node.
 * @param targetFeeAccount A base token account which will receive the cranking reward.
 * @param marketAddress The market's address
 * @returns An array of signer accounts and an array of instructions
 */
export declare function crankLiquidation(connection: Connection, targetFeeAccount: PublicKey, marketAddress: PublicKey, bonfida_bnb?: PublicKey): Promise<PrimedTransaction>;
/**
 * A permissionless operation which will crank funding operations for the market. This operation is run at a frequency higher than the funding
 * frequency in order to maintain an estimator of the funding ratio mean for the current funding period.
 *
 * @param connection The solana connection object to the RPC node.
 * @param marketAddress The market's address
 * @returns An array of signer accounts and an array of instructions.
 */
export declare function crankFunding(connection: Connection, marketAddress: PublicKey): Promise<PrimedTransaction>;
/**
 * This operation is used to create UserAccount and to add a balance of base tokens. The account is used to store all currently open
 * positions on the market. It is very important to keep this account sufficiently funded when it contains open positions since
 * its balance is used to perform and receive funding payments. An insufficient balance can yield to a liquidation of all open positions
 * and loss of funds.
 *
 * @param connection The solana connection object to the RPC node.
 * @param marketAddress The market's address
 * @param amount The amount of base tokens to add to the account.
 * @param feePayer The address that will pay for this operation's transaction fees.
 * @param sourceQuoteAccount The source base token account.
 * @param sourceOwnerAccount The owner of the source base token account.
 * @param userAccount (optional) The user account's address. When left undefined, a new user account is created.
 * @param instanceIndex (optional) The index number of the market instance which should be used when creating the account. This
 * paramater is ignored when not creating a new account.
 * @returns An array of signer accounts and an array of instructions. When creating a new user account, the first signer is this new user account.
 */
export declare function addBudget(connection: Connection, marketAddress: PublicKey, amount: number, feePayer: PublicKey, sourceQuoteAccount: PublicKey, sourceOwnerAccount: PublicKey, userAccount?: PublicKey): Promise<PrimedTransaction>;
/**
 * This operation is used to withdraw funds from a UserAccount. Users should be careful when withdrawing funds to leave enough for potential
 * funding payments on open positions.
 *
 * @param connection The solana connection object to the RPC node.
 * @param marketAddress The market's address
 * @param amount The amount of base tokens to be withdrawn from the account.
 * @param targetQuoteAccount The target base token account which will receive the withdrawn funds.
 * @param userAccountOwner The owner of the user account. This account will need to sign the eventual transaction.
 * @param userAccount The user account's address.
 * @returns An array of signer accounts and an array of instructions. The user account owner should sign the resulting transaction.
 */
export declare function withdrawBudget(connection: Connection, marketAddress: PublicKey, amount: number, targetQuoteAccount: PublicKey, userAccountOwner: PublicKey, userAccount: PublicKey): Promise<PrimedTransaction>;
/**
 * This operations allows user to increase a position's collateral or size, which can affect the position's leverage.
 *
 * @param connection The solana connection object to the RPC node.
 * @param marketAddress The market's address
 * @param addCollateral The amount of collateral to add to the position. This can be used to decrease the position's leverage.
 * @param leverage A non-zero value is used to increase the position's size. The resulting increase in position size will be equal to addCollateral * leverage.
 * @param positionIndex The index of the target position in the user's account.
 * @param userAccountOwner The owner of the user account.
 * @param userAccount The user account.
 * @param discountAccount (optional) A FIDA token account. Sufficient FIDA stake allows access to more efficient fee levels.
 * @param discountAccountOwner (must be specified if discountAccount is specified). The owner of the FIDA discountAccount. This account must sign
 * the eventual openPosition transaction.
 * @param referrerAccount A referrer's account which will receive a fixed portion of protocol fees.
 * @returns An array of signer accounts and an array of instructions. The user account owner should sign the resulting transaction.
 */
export declare function increasePosition(connection: Connection, marketAddress: PublicKey, addCollateral: number, leverage: number, positionIndex: number, userAccountOwner: PublicKey, userAccount: PublicKey, bonfida_bnb?: PublicKey, discountAccount?: PublicKey, discountAccountOwner?: PublicKey, referrerAccount?: PublicKey, predictedEntryPrice?: number, maximumSlippageMargin?: number): Promise<PrimedTransaction>;
/**
 * This operation is a permissionless crank used to extract or inject funding from/into all user accounts. This operation is run on all active accounts
 * within any funding period.
 *
 * @param connection The solana connection object to the RPC node.
 * @param marketAddress The market's address
 * @param userAccount The user account.
 * @returns An array of signer accounts and an array of instructions.
 */
export declare function fundingExtraction(connection: Connection, marketAddress: PublicKey, instanceIndex: number, userAccount: PublicKey): Promise<PrimedTransaction>;
/**
 * This operation closes a user account and should be signed by its owner. The user account should have no
 * open positions and no remaining balance in order for this operation to succeed.
 *
 * @param userAccount The user account.
 * @param userAccountOwner The owner of the user account.
 * @param lamportsTarget The account which will receive the closed account's lamports (SOL).
 * @returns An array of signer accounts and an array of instructions.
 */
export declare function closeAccount(userAccount: PublicKey, userAccountOwner: PublicKey, lamportsTarget: PublicKey): Promise<PrimedTransaction>;
/**
 * This operation is used to transfer the ownership of a UserAccount to a new address.
 *
 * @param userAccountOwner The owner of the user account. This account will need to sign the eventual transaction.
 * @param userAccount The user account's address.
 * @param newUserAccountOwner The new owner of the user account.
 * @returns An array of signer accounts and an array of instructions. The user account owner should sign the resulting transaction.
 */
export declare function transferUserAccount(userAccountOwner: PublicKey, userAccount: PublicKey, newUserAccountOwner: PublicKey): Promise<PrimedTransaction>;
/**
 * This operation is used to transfer a position from a UserAccount to another.
 *
 * @param sourceUserAccountOwner The owner of the source user account. This account will need to sign the eventual transaction.
 * @param sourceUserAccount The source user account's address.
 * @param destinationUserAccountOwner The owner of the destination user account. This account will need to sign the eventual transaction.
 * @param destinationUserAccount The source user account's address.
 * @returns An array of signer accounts and an array of instructions. The user account owner should sign the resulting transaction.
 */
export declare function transferPosition(positionIndex: number, sourceUserAccountOwner: PublicKey, sourceUserAccount: PublicKey, destinationUserAccountOwner: PublicKey, destinationUserAccount: PublicKey): Promise<PrimedTransaction>;
