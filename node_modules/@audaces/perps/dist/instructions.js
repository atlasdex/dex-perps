"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseInstructionData = exports.transferPositionInstruction = exports.transferUserAccountInstruction = exports.closeAccountInstruction = exports.extractFundingInstruction = exports.crankFundingInstruction = exports.crankLiquidationInstruction = exports.collectGarbageInstruction = exports.closePositionInstruction = exports.increasePositionInstruction = exports.withdrawBudgetInstruction = exports.addBudgetInstruction = exports.openPositionInstruction = exports.updateOracleAccountInstruction = exports.addInstanceInstruction = exports.createMarketInstruction = exports.FUNDING_EXTRACTION_LABEL = exports.TRADE_LABEL = exports.FUNDING_LABEL = exports.LIQUIDATION_LABEL = exports.BONFIDA_BNB = exports.PositionType = void 0;
const spl_token_1 = require("@solana/spl-token");
const web3_js_1 = require("@solana/web3.js");
const borsh_1 = require("borsh");
var PositionType;
(function (PositionType) {
    PositionType[PositionType["Short"] = 0] = "Short";
    PositionType[PositionType["Long"] = 1] = "Long";
})(PositionType = exports.PositionType || (exports.PositionType = {}));
exports.BONFIDA_BNB = new web3_js_1.PublicKey("FxqKVkCMtTVmJ6cEibvQeNJCtT4JWEzJzhZ3bFNmR6zu");
exports.LIQUIDATION_LABEL = new web3_js_1.PublicKey("LiquidationRecord11111111111111111111111111");
exports.FUNDING_LABEL = new web3_js_1.PublicKey("FundingRecord1111111111111111111111111111111");
exports.TRADE_LABEL = new web3_js_1.PublicKey("TradeRecord11111111111111111111111111111111");
exports.FUNDING_EXTRACTION_LABEL = new web3_js_1.PublicKey("FundingExtraction111111111111111111111111111");
class createMarketInstruction {
    constructor(obj) {
        this.tag = 0;
        this.signerNonce = obj.signerNonce;
        this.marketSymbol = obj.marketSymbol;
        this.initialVPcAmount = obj.initialVPcAmount;
        this.coinDecimals = obj.coinDecimals;
        this.quoteDecimals = obj.quoteDecimals;
    }
    serialize() {
        return borsh_1.serialize(createMarketInstruction.schema, this);
    }
    getInstruction(perpsProgramId, marketAccount, oracleAccount, adminAccount, marketVault) {
        const data = Buffer.from(this.serialize());
        let keys = [
            {
                pubkey: marketAccount,
                isSigner: false,
                isWritable: true,
            },
            {
                pubkey: web3_js_1.SYSVAR_CLOCK_PUBKEY,
                isSigner: false,
                isWritable: false,
            },
            {
                pubkey: oracleAccount,
                isSigner: false,
                isWritable: false,
            },
            {
                pubkey: adminAccount,
                isSigner: false,
                isWritable: false,
            },
            {
                pubkey: marketVault,
                isSigner: false,
                isWritable: true,
            },
        ];
        return new web3_js_1.TransactionInstruction({
            keys,
            programId: perpsProgramId,
            data,
        });
    }
}
exports.createMarketInstruction = createMarketInstruction;
createMarketInstruction.schema = new Map([
    [
        createMarketInstruction,
        {
            kind: "struct",
            fields: [
                ["tag", "u8"],
                ["signerNonce", "u8"],
                ["marketSymbol", "string"],
                ["initialVPcAmount", "u64"],
                ["coinDecimals", "u8"],
                ["quoteDecimals", "u8"],
            ],
        },
    ],
]);
class addInstanceInstruction {
    constructor() {
        this.tag = 1;
    }
    serialize() {
        return borsh_1.serialize(addInstanceInstruction.schema, this);
    }
    getInstruction(perpsProgramId, marketAccount, instanceAccount, marketAdmin, memory_pages) {
        const data = Buffer.from(this.serialize());
        let keys = [
            {
                pubkey: marketAccount,
                isSigner: false,
                isWritable: true,
            },
            {
                pubkey: marketAdmin,
                isSigner: true,
                isWritable: false,
            },
            {
                pubkey: instanceAccount,
                isSigner: false,
                isWritable: true,
            },
        ];
        keys = keys.concat(memory_pages.map((m) => {
            return {
                pubkey: m,
                isSigner: false,
                isWritable: true,
            };
        }));
        return new web3_js_1.TransactionInstruction({
            keys,
            programId: perpsProgramId,
            data,
        });
    }
}
exports.addInstanceInstruction = addInstanceInstruction;
addInstanceInstruction.schema = new Map([
    [
        addInstanceInstruction,
        {
            kind: "struct",
            fields: [["tag", "u8"]],
        },
    ],
]);
class updateOracleAccountInstruction {
    constructor() {
        this.tag = 2;
    }
    serialize() {
        return borsh_1.serialize(updateOracleAccountInstruction.schema, this);
    }
    getInstruction(perpsProgramId, marketAccount, pythOracleMappingAccount, pythOracleProductAccount, pythOraclePriceAccount) {
        const data = Buffer.from(this.serialize());
        let keys = [
            {
                pubkey: marketAccount,
                isSigner: false,
                isWritable: true,
            },
            {
                pubkey: pythOracleMappingAccount,
                isSigner: false,
                isWritable: false,
            },
            {
                pubkey: pythOracleProductAccount,
                isSigner: false,
                isWritable: false,
            },
            {
                pubkey: pythOraclePriceAccount,
                isSigner: false,
                isWritable: false,
            },
        ];
        return new web3_js_1.TransactionInstruction({
            keys,
            programId: perpsProgramId,
            data,
        });
    }
}
exports.updateOracleAccountInstruction = updateOracleAccountInstruction;
updateOracleAccountInstruction.schema = new Map([
    [
        updateOracleAccountInstruction,
        {
            kind: "struct",
            fields: [["tag", "u8"]],
        },
    ],
]);
class openPositionInstruction {
    constructor(obj) {
        this.tag = 3;
        this.side = obj.side;
        this.collateral = obj.collateral;
        this.instanceIndex = obj.instanceIndex;
        this.leverage = obj.leverage;
        this.predictedEntryPrice = obj.predictedEntryPrice;
        this.maximumSlippageMargin = obj.maximumSlippageMargin;
    }
    serialize() {
        return borsh_1.serialize(openPositionInstruction.schema, this);
    }
    getInstruction(perpsProgramId, marketAccount, instanceAccount, marketSigner, marketVault, userAccountOwner, userAccount, memoryPages, bonfida_bnb, oracleAccount, discountAccount, discountAccountOwner, referrerAccount) {
        const data = Buffer.from(this.serialize());
        let keys = [
            {
                pubkey: spl_token_1.TOKEN_PROGRAM_ID,
                isSigner: false,
                isWritable: false,
            },
            {
                pubkey: web3_js_1.SYSVAR_CLOCK_PUBKEY,
                isSigner: false,
                isWritable: false,
            },
            {
                pubkey: marketAccount,
                isSigner: false,
                isWritable: true,
            },
            {
                pubkey: instanceAccount,
                isSigner: false,
                isWritable: true,
            },
            {
                pubkey: marketSigner,
                isSigner: false,
                isWritable: false,
            },
            {
                pubkey: marketVault,
                isSigner: false,
                isWritable: true,
            },
            {
                pubkey: bonfida_bnb,
                isSigner: false,
                isWritable: true,
            },
            {
                pubkey: userAccountOwner,
                isSigner: true,
                isWritable: false,
            },
            {
                pubkey: userAccount,
                isSigner: false,
                isWritable: true,
            },
            {
                pubkey: exports.TRADE_LABEL,
                isSigner: false,
                isWritable: false,
            },
            {
                pubkey: oracleAccount,
                isSigner: false,
                isWritable: false,
            },
        ];
        keys = keys.concat(memoryPages.map((m) => {
            return {
                pubkey: m,
                isSigner: false,
                isWritable: true,
            };
        }));
        if (!!discountAccount) {
            if (!discountAccountOwner) {
                throw "The owner of the discount account must be specified as well";
            }
            keys.push({
                pubkey: discountAccount,
                isSigner: false,
                isWritable: false,
            });
            keys.push({
                pubkey: discountAccountOwner,
                isSigner: true,
                isWritable: false,
            });
        }
        if (!!referrerAccount) {
            keys.push({
                pubkey: referrerAccount,
                isSigner: false,
                isWritable: true,
            });
        }
        return new web3_js_1.TransactionInstruction({
            keys,
            programId: perpsProgramId,
            data,
        });
    }
}
exports.openPositionInstruction = openPositionInstruction;
openPositionInstruction.schema = new Map([
    [
        openPositionInstruction,
        {
            kind: "struct",
            fields: [
                ["tag", "u8"],
                ["side", "u8"],
                ["collateral", "u64"],
                ["instanceIndex", "u8"],
                ["leverage", "u64"],
                ["predictedEntryPrice", "u64"],
                ["maximumSlippageMargin", "u64"],
            ],
        },
    ],
]);
class addBudgetInstruction {
    constructor(obj) {
        this.amount = obj.amount;
        this.tag = 4;
    }
    serialize() {
        return borsh_1.serialize(addBudgetInstruction.schema, this);
    }
    getInstruction(perpsProgramId, spl_token_program, marketAccount, marketVault, sourceTokenAccount, sourceOwner, userAccount) {
        const data = Buffer.from(this.serialize());
        let keys = [
            {
                pubkey: spl_token_program,
                isSigner: false,
                isWritable: false,
            },
            {
                pubkey: marketAccount,
                isSigner: false,
                isWritable: true,
            },
            {
                pubkey: marketVault,
                isSigner: false,
                isWritable: true,
            },
            {
                pubkey: userAccount,
                isSigner: false,
                isWritable: true,
            },
            {
                pubkey: sourceOwner,
                isSigner: true,
                isWritable: false,
            },
            {
                pubkey: sourceTokenAccount,
                isSigner: false,
                isWritable: true,
            },
        ];
        return new web3_js_1.TransactionInstruction({
            keys,
            programId: perpsProgramId,
            data,
        });
    }
}
exports.addBudgetInstruction = addBudgetInstruction;
addBudgetInstruction.schema = new Map([
    [
        addBudgetInstruction,
        {
            kind: "struct",
            fields: [
                ["tag", "u8"],
                ["amount", "u64"],
            ],
        },
    ],
]);
class withdrawBudgetInstruction {
    constructor(obj) {
        this.amount = obj.amount;
        this.tag = 5;
    }
    serialize() {
        return borsh_1.serialize(withdrawBudgetInstruction.schema, this);
    }
    getInstruction(perpsProgramId, spl_token_program, marketAccount, marketVault, targetTokenAccount, marketSigner, userAccount, userAccountOwner) {
        const data = Buffer.from(this.serialize());
        let keys = [
            {
                pubkey: spl_token_program,
                isSigner: false,
                isWritable: false,
            },
            {
                pubkey: marketAccount,
                isSigner: false,
                isWritable: true,
            },
            {
                pubkey: marketSigner,
                isSigner: false,
                isWritable: false,
            },
            {
                pubkey: marketVault,
                isSigner: false,
                isWritable: true,
            },
            {
                pubkey: userAccountOwner,
                isSigner: true,
                isWritable: false,
            },
            {
                pubkey: userAccount,
                isSigner: false,
                isWritable: true,
            },
            {
                pubkey: targetTokenAccount,
                isSigner: false,
                isWritable: true,
            },
        ];
        return new web3_js_1.TransactionInstruction({
            keys,
            programId: perpsProgramId,
            data,
        });
    }
}
exports.withdrawBudgetInstruction = withdrawBudgetInstruction;
withdrawBudgetInstruction.schema = new Map([
    [
        withdrawBudgetInstruction,
        {
            kind: "struct",
            fields: [
                ["tag", "u8"],
                ["amount", "u64"],
            ],
        },
    ],
]);
class increasePositionInstruction {
    constructor(obj) {
        this.tag = 6;
        this.addCollateral = obj.addCollateral;
        this.instanceIndex = obj.instanceIndex;
        this.leverage = obj.leverage;
        this.positionIndex = obj.positionIndex;
        this.predictedEntryPrice = obj.predictedEntryPrice;
        this.maximumSlippageMargin = obj.maximumSlippageMargin;
    }
    serialize() {
        return borsh_1.serialize(increasePositionInstruction.schema, this);
    }
    getInstruction(perpsProgramId, clock_sysvar, marketAccount, marketSigner, marketVault, bonfida_bnb, instanceAccount, userAccount, userAccountOwner, oracleAccount, memoryPages, discountAccount, discountAccountOwner, referrerAccount) {
        const data = Buffer.from(this.serialize());
        let keys = [
            {
                pubkey: spl_token_1.TOKEN_PROGRAM_ID,
                isSigner: false,
                isWritable: false,
            },
            {
                pubkey: clock_sysvar,
                isSigner: false,
                isWritable: false,
            },
            {
                pubkey: marketAccount,
                isSigner: false,
                isWritable: true,
            },
            {
                pubkey: marketSigner,
                isSigner: false,
                isWritable: false,
            },
            {
                pubkey: marketVault,
                isSigner: false,
                isWritable: true,
            },
            {
                pubkey: bonfida_bnb,
                isSigner: false,
                isWritable: true,
            },
            {
                pubkey: instanceAccount,
                isSigner: false,
                isWritable: true,
            },
            {
                pubkey: userAccountOwner,
                isSigner: true,
                isWritable: false,
            },
            {
                pubkey: userAccount,
                isSigner: false,
                isWritable: true,
            },
            {
                pubkey: exports.TRADE_LABEL,
                isSigner: false,
                isWritable: false,
            },
            {
                pubkey: oracleAccount,
                isSigner: false,
                isWritable: false,
            },
        ];
        keys = keys.concat(memoryPages.map((m) => {
            return {
                pubkey: m,
                isSigner: false,
                isWritable: true,
            };
        }));
        if (!!discountAccount) {
            if (!discountAccountOwner) {
                throw "The owner of the discount account must be specified as well";
            }
            keys.push({
                pubkey: discountAccount,
                isSigner: false,
                isWritable: false,
            });
            keys.push({
                pubkey: discountAccountOwner,
                isSigner: true,
                isWritable: false,
            });
        }
        if (!!referrerAccount) {
            keys.push({
                pubkey: referrerAccount,
                isSigner: false,
                isWritable: true,
            });
        }
        return new web3_js_1.TransactionInstruction({
            keys,
            programId: perpsProgramId,
            data,
        });
    }
}
exports.increasePositionInstruction = increasePositionInstruction;
increasePositionInstruction.schema = new Map([
    [
        increasePositionInstruction,
        {
            kind: "struct",
            fields: [
                ["tag", "u8"],
                ["addCollateral", "u64"],
                ["instanceIndex", "u8"],
                ["leverage", "u64"],
                ["positionIndex", [2]],
                ["predictedEntryPrice", "u64"],
                ["maximumSlippageMargin", "u64"],
            ],
        },
    ],
]);
class closePositionInstruction {
    constructor(obj) {
        this.tag = 7;
        this.positionIndex = obj.positionIndex;
        this.closingCollateral = obj.closingCollateral;
        this.closingVCoin = obj.closingVCoin;
        this.predictedEntryPrice = obj.predictedEntryPrice;
        this.maximumSlippageMargin = obj.maximumSlippageMargin;
    }
    serialize() {
        return borsh_1.serialize(closePositionInstruction.schema, this);
    }
    getInstruction(perpsProgramId, marketSigner, marketVault, oracleAccount, marketAccount, instanceAccount, positionOwner, userAccount, memory_pages, bonfida_bnb, discountAccount, discountAccountOwner, referrerAccount) {
        const data = Buffer.from(this.serialize());
        let keys = [
            {
                pubkey: spl_token_1.TOKEN_PROGRAM_ID,
                isSigner: false,
                isWritable: false,
            },
            {
                pubkey: web3_js_1.SYSVAR_CLOCK_PUBKEY,
                isSigner: false,
                isWritable: false,
            },
            {
                pubkey: marketAccount,
                isSigner: false,
                isWritable: true,
            },
            {
                pubkey: instanceAccount,
                isSigner: false,
                isWritable: true,
            },
            {
                pubkey: marketSigner,
                isSigner: false,
                isWritable: false,
            },
            {
                pubkey: marketVault,
                isSigner: false,
                isWritable: true,
            },
            {
                pubkey: bonfida_bnb,
                isSigner: false,
                isWritable: true,
            },
            {
                pubkey: oracleAccount,
                isSigner: false,
                isWritable: false,
            },
            {
                pubkey: positionOwner,
                isSigner: true,
                isWritable: false,
            },
            {
                pubkey: userAccount,
                isSigner: false,
                isWritable: true,
            },
            {
                pubkey: exports.TRADE_LABEL,
                isSigner: false,
                isWritable: false,
            },
        ];
        keys = keys.concat(memory_pages.map((m) => {
            return {
                pubkey: m,
                isSigner: false,
                isWritable: true,
            };
        }));
        if (!!discountAccount) {
            if (!discountAccountOwner) {
                throw "The owner of the discount account must be specified as well";
            }
            keys.push({
                pubkey: discountAccount,
                isSigner: false,
                isWritable: false,
            });
            keys.push({
                pubkey: discountAccountOwner,
                isSigner: true,
                isWritable: false,
            });
        }
        if (!!referrerAccount) {
            keys.push({
                pubkey: referrerAccount,
                isSigner: false,
                isWritable: true,
            });
        }
        return new web3_js_1.TransactionInstruction({
            keys,
            programId: perpsProgramId,
            data,
        });
    }
}
exports.closePositionInstruction = closePositionInstruction;
closePositionInstruction.schema = new Map([
    [
        closePositionInstruction,
        {
            kind: "struct",
            fields: [
                ["tag", "u8"],
                ["positionIndex", [2]],
                ["closingCollateral", "u64"],
                ["closingVCoin", "u64"],
                ["predictedEntryPrice", "u64"],
                ["maximumSlippageMargin", "u64"],
            ],
        },
    ],
]);
class collectGarbageInstruction {
    constructor(obj) {
        this.maxIterations = obj.maxIterations;
        this.instanceIndex = obj.instanceIndex;
        this.tag = 8;
    }
    serialize() {
        return borsh_1.serialize(collectGarbageInstruction.schema, this);
    }
    getInstruction(perpsProgramId, splTokenProgram, marketAccount, instanceAccount, marketVault, marketSigner, targetQuoteAccount, memory_pages) {
        const data = Buffer.from(this.serialize());
        let keys = [
            {
                pubkey: splTokenProgram,
                isSigner: false,
                isWritable: false,
            },
            {
                pubkey: marketAccount,
                isSigner: false,
                isWritable: true,
            },
            {
                pubkey: instanceAccount,
                isSigner: false,
                isWritable: true,
            },
            {
                pubkey: marketVault,
                isSigner: false,
                isWritable: true,
            },
            {
                pubkey: marketSigner,
                isSigner: false,
                isWritable: false,
            },
            {
                pubkey: targetQuoteAccount,
                isSigner: false,
                isWritable: true,
            },
        ];
        keys = keys.concat(memory_pages.map((m) => {
            return {
                pubkey: m,
                isSigner: false,
                isWritable: true,
            };
        }));
        return new web3_js_1.TransactionInstruction({
            keys,
            programId: perpsProgramId,
            data,
        });
    }
}
exports.collectGarbageInstruction = collectGarbageInstruction;
collectGarbageInstruction.schema = new Map([
    [
        collectGarbageInstruction,
        {
            kind: "struct",
            fields: [
                ["tag", "u8"],
                ["instanceIndex", "u8"],
                ["maxIterations", "u64"],
            ],
        },
    ],
]);
class crankLiquidationInstruction {
    constructor(obj) {
        this.instanceIndex = obj.instanceIndex;
        this.tag = 9;
    }
    serialize() {
        return borsh_1.serialize(crankLiquidationInstruction.schema, this);
    }
    getInstruction(perpsProgramId, splTokenProgram, marketAccount, instanceAccount, bonfida_bnb, marketVault, marketSigner, oracleAccount, targetQuoteAccount, memory_pages) {
        const data = Buffer.from(this.serialize());
        let keys = [
            {
                pubkey: splTokenProgram,
                isSigner: false,
                isWritable: false,
            },
            {
                pubkey: marketAccount,
                isSigner: false,
                isWritable: true,
            },
            {
                pubkey: instanceAccount,
                isSigner: false,
                isWritable: true,
            },
            {
                pubkey: marketSigner,
                isSigner: false,
                isWritable: false,
            },
            {
                pubkey: bonfida_bnb,
                isSigner: false,
                isWritable: true,
            },
            {
                pubkey: marketVault,
                isSigner: false,
                isWritable: true,
            },
            {
                pubkey: oracleAccount,
                isSigner: false,
                isWritable: false,
            },
            {
                pubkey: targetQuoteAccount,
                isSigner: false,
                isWritable: true,
            },
            {
                pubkey: exports.LIQUIDATION_LABEL,
                isSigner: false,
                isWritable: false,
            },
        ];
        keys = keys.concat(memory_pages.map((m) => {
            return {
                pubkey: m,
                isSigner: false,
                isWritable: true,
            };
        }));
        return new web3_js_1.TransactionInstruction({
            keys,
            programId: perpsProgramId,
            data,
        });
    }
}
exports.crankLiquidationInstruction = crankLiquidationInstruction;
crankLiquidationInstruction.schema = new Map([
    [
        crankLiquidationInstruction,
        {
            kind: "struct",
            fields: [
                ["tag", "u8"],
                ["instanceIndex", "u8"],
            ],
        },
    ],
]);
class crankFundingInstruction {
    constructor() {
        this.tag = 10;
    }
    serialize() {
        return borsh_1.serialize(crankFundingInstruction.schema, this);
    }
    getInstruction(perpsProgramId, clockSysvarAccount, marketAccount, oracleAccount) {
        const data = Buffer.from(this.serialize());
        let keys = [
            {
                pubkey: clockSysvarAccount,
                isSigner: false,
                isWritable: false,
            },
            {
                pubkey: marketAccount,
                isSigner: false,
                isWritable: true,
            },
            {
                pubkey: oracleAccount,
                isSigner: false,
                isWritable: false,
            },
            {
                pubkey: exports.FUNDING_LABEL,
                isSigner: false,
                isWritable: false,
            },
        ];
        return new web3_js_1.TransactionInstruction({
            keys,
            programId: perpsProgramId,
            data,
        });
    }
}
exports.crankFundingInstruction = crankFundingInstruction;
crankFundingInstruction.schema = new Map([
    [
        crankFundingInstruction,
        {
            kind: "struct",
            fields: [["tag", "u8"]],
        },
    ],
]);
class extractFundingInstruction {
    constructor(obj) {
        this.tag = 11;
        this.instanceIndex = obj.instanceIndex;
    }
    serialize() {
        return borsh_1.serialize(extractFundingInstruction.schema, this);
    }
    getInstruction(perpsProgramId, marketAccount, instanceAccount, userAccount, oracleAccount, memory_pages) {
        const data = Buffer.from(this.serialize());
        let keys = [
            {
                pubkey: marketAccount,
                isSigner: false,
                isWritable: true,
            },
            {
                pubkey: instanceAccount,
                isSigner: false,
                isWritable: true,
            },
            {
                pubkey: userAccount,
                isSigner: false,
                isWritable: true,
            },
            {
                pubkey: exports.FUNDING_EXTRACTION_LABEL,
                isSigner: false,
                isWritable: false,
            },
            {
                pubkey: oracleAccount,
                isSigner: false,
                isWritable: false,
            },
        ];
        keys = keys.concat(memory_pages.map((m) => {
            return {
                pubkey: m,
                isSigner: false,
                isWritable: true,
            };
        }));
        return new web3_js_1.TransactionInstruction({
            keys,
            programId: perpsProgramId,
            data,
        });
    }
}
exports.extractFundingInstruction = extractFundingInstruction;
extractFundingInstruction.schema = new Map([
    [
        extractFundingInstruction,
        {
            kind: "struct",
            fields: [
                ["tag", "u8"],
                ["instanceIndex", "u8"],
            ],
        },
    ],
]);
class closeAccountInstruction {
    constructor() {
        this.tag = 13;
    }
    serialize() {
        return borsh_1.serialize(closeAccountInstruction.schema, this);
    }
    getInstruction(perpsProgramId, userAccount, userAccountOwner, lamportsTarget) {
        const data = Buffer.from(this.serialize());
        let keys = [
            {
                pubkey: userAccount,
                isSigner: false,
                isWritable: true,
            },
            {
                pubkey: userAccountOwner,
                isSigner: true,
                isWritable: false,
            },
            {
                pubkey: lamportsTarget,
                isSigner: false,
                isWritable: false,
            },
        ];
        return new web3_js_1.TransactionInstruction({
            keys,
            programId: perpsProgramId,
            data,
        });
    }
}
exports.closeAccountInstruction = closeAccountInstruction;
closeAccountInstruction.schema = new Map([
    [
        closeAccountInstruction,
        {
            kind: "struct",
            fields: [["tag", "u8"]],
        },
    ],
]);
class transferUserAccountInstruction {
    constructor() {
        this.tag = 16;
    }
    serialize() {
        return borsh_1.serialize(withdrawBudgetInstruction.schema, this);
    }
    getInstruction(perpsProgramId, userAccount, userAccountOwner, newUserAccountOwner) {
        const data = Buffer.from(this.serialize());
        let keys = [
            {
                pubkey: userAccountOwner,
                isSigner: true,
                isWritable: false,
            },
            {
                pubkey: userAccount,
                isSigner: false,
                isWritable: true,
            },
            {
                pubkey: newUserAccountOwner,
                isSigner: false,
                isWritable: false,
            },
        ];
        return new web3_js_1.TransactionInstruction({
            keys,
            programId: perpsProgramId,
            data,
        });
    }
}
exports.transferUserAccountInstruction = transferUserAccountInstruction;
transferUserAccountInstruction.schema = new Map([
    [
        withdrawBudgetInstruction,
        {
            kind: "struct",
            fields: [["tag", "u8"]],
        },
    ],
]);
class transferPositionInstruction {
    constructor(positionIndex) {
        this.tag = 17;
        this.positionIndex = positionIndex;
    }
    serialize() {
        return borsh_1.serialize(withdrawBudgetInstruction.schema, this);
    }
    getInstruction(perpsProgramId, sourceUserAccount, sourceUserAccountOwner, destinationUserAccount, destinationUserAccountOwner) {
        const data = Buffer.from(this.serialize());
        let keys = [
            {
                pubkey: sourceUserAccountOwner,
                isSigner: true,
                isWritable: false,
            },
            {
                pubkey: sourceUserAccount,
                isSigner: false,
                isWritable: true,
            },
            {
                pubkey: destinationUserAccountOwner,
                isSigner: true,
                isWritable: false,
            },
            {
                pubkey: destinationUserAccount,
                isSigner: false,
                isWritable: true,
            },
        ];
        return new web3_js_1.TransactionInstruction({
            keys,
            programId: perpsProgramId,
            data,
        });
    }
}
exports.transferPositionInstruction = transferPositionInstruction;
transferPositionInstruction.schema = new Map([
    [
        withdrawBudgetInstruction,
        {
            kind: "struct",
            fields: [
                ["tag", "u8"],
                ["positionIndex", "u16"],
            ],
        },
    ],
]);
function parseInstructionData(buffer) {
    let types = [
        createMarketInstruction,
        addInstanceInstruction,
        updateOracleAccountInstruction,
        openPositionInstruction,
        addBudgetInstruction,
        withdrawBudgetInstruction,
        increasePositionInstruction,
        closePositionInstruction,
        collectGarbageInstruction,
        crankLiquidationInstruction,
        crankFundingInstruction,
        extractFundingInstruction,
        closeAccountInstruction,
        transferUserAccountInstruction,
        transferPositionInstruction,
    ];
    let t = types[buffer[0]];
    return borsh_1.deserializeUnchecked(t.schema, t, buffer);
}
exports.parseInstructionData = parseInstructionData;
//# sourceMappingURL=instructions.js.map